{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Backend: Implement Global Budget Circuit Breaker",
        "description": "Set up the serverless backend environment and implement the non-negotiable Global Budget Circuit Breaker to cap weekly API spend. The core logic has been implemented using a Cloudflare Worker; next steps involve deployment and integration.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "The implementation uses a Cloudflare Worker located at `functions/circuit-breaker/index.ts`. It reads the `weekly_spend_usd` and `weekly_cap_usd` values from a Cloudflare KV store named `BUDGET_KV`. This worker acts as a middleware for the AI proxy. If the spend exceeds the cap, the worker returns a '503 Service Unavailable' error to halt further processing and prevent additional costs.\n\nPseudo-code for the worker:\n```typescript\n// In functions/circuit-breaker/index.ts\nexport default {\n  async fetch(request, env, ctx) {\n    const weeklySpend = await env.BUDGET_KV.get('weekly_spend_usd') || 0;\n    const weeklyCap = await env.BUDGET_KV.get('weekly_cap_usd') || 100;\n\n    if (parseFloat(weeklySpend) >= parseFloat(weeklyCap)) {\n      return new Response('Budget exceeded. Service temporarily unavailable.', { status: 503 });\n    }\n    // If budget is okay, the request proceeds to the main AI proxy.\n  }\n}\n```",
        "testStrategy": "Unit test the budget checking logic within the worker. Create integration tests that simulate hitting the budget limit and verify that the worker correctly returns a 503 error. Manually test by setting a low budget in the KV store, making API calls, and confirming the service is disabled.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Create the initial Cloudflare Worker at `functions/circuit-breaker/index.ts`. The worker reads `weekly_spend_usd` and `weekly_cap_usd` from a KV store named `BUDGET_KV` and returns a 503 error if the cap is exceeded.",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Deploy the Cloudflare Worker and configure the `BUDGET_KV` namespace in the production environment.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Integrate the deployed circuit breaker as a middleware or pre-processing step for the AI Proxy Service (Task 3). Ensure the proxy halts execution when the worker returns a 503 status.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Backend: User Identity and Credit Tracking Service",
        "description": "Create a backend service to manage user credits. This service will use `chrome.identity` to generate a stable, anonymous user ID, provision initial credits, and decrement them upon use.",
        "details": "Create a serverless function endpoint `/user/status`. On first call with a new `chrome.identity` token, create a user record in a database (e.g., DynamoDB) with `userId`, `credits: 150`, and `monthlyResetDate`. Subsequent calls return the current credit count. Create another internal endpoint `/credits/decrement` for the AI proxy to call. This endpoint should be secured and only callable by other backend services. \n\nSchema for User Table:\n- `userId` (Partition Key, String from `chrome.identity` hash)\n- `creditsRemaining` (Number)\n- `lastResetTimestamp` (Number)",
        "testStrategy": "Unit test the credit provisioning and decrementing logic. Integration test the API endpoints: verify a new user gets 150 credits, and that calling the decrement endpoint correctly reduces the count. Test the edge case where credits are zero.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Backend: AI Proxy Service for Trial Mode",
        "description": "Developed a serverless function that acts as a secure proxy for the free trial AI mode. It handles requests from the extension, validates credits, and calls the designated AI model API.",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "The implementation is a Cloudflare Worker located at `functions/ai-proxy/index.ts`. This worker acts as the central orchestrator for the free trial mode. The logic is as follows:\n1. Receives the user's anonymous token and text from the extension via the `/proxy/ai-process` endpoint.\n2. Calls the Credit Tracking Service (Task 2) to verify the user has > 0 credits. Returns an error if credits are exhausted.\n3. Forwards the request to the `GPT OSS 20B` model API hosted by Groq, using the securely stored company API key.\n4. On a successful response from the AI model, it calls the Credit Tracking Service again to decrement the user's credit count.\n5. Tracks the cost of the API call and updates the `weekly_spend_usd` value in the `BUDGET_KV` store (from Task 1).\n6. Returns the processed text from the AI model back to the extension.",
        "testStrategy": "Integration test the entire flow: send a request, verify credit check, mock the external AI API call, verify credit decrement, and check the response format. Test failure modes: no credits, upstream API failure, etc. Use a test API key and a separate budget for testing.",
        "subtasks": [
          {
            "id": 1,
            "title": "",
            "description": "Implement the core Cloudflare Worker at `functions/ai-proxy/index.ts` to handle incoming requests.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "",
            "description": "Integrate with the Credit Tracking Service to check for available credits before processing.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "",
            "description": "Implement the API call to the third-party AI provider (Groq) for text processing.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "",
            "description": "On successful AI response, call the Credit Tracking Service to decrement the user's credit count.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "",
            "description": "Integrate with the Global Budget system by updating the spend counter in `BUDGET_KV` after each successful call.",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Extension: MV3 Scaffold and Unified Popup UI Shell",
        "description": "Set up the basic Chrome Extension using the Manifest V3 standard and created the main popup UI shell. The UI includes a unified interface for mode selection, credit display, and inline settings.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "The project was scaffolded using WXT (Web Extension Toolkit) and React. The `wxt.config.ts` file was configured to include `storage` and `identity` permissions for future use. The main popup component, `SimplifiedPopup.tsx`, was created to serve as the UI shell. It includes placeholders for the mode toggle and inline settings panel, and implements the display logic for the user's remaining free trial credits.",
        "testStrategy": "Loaded the extension in a development environment. Verified that the popup opens correctly and the React-based UI renders without errors. Confirmed that the manifest (generated by WXT) is valid for MV3. Manually checked that placeholders for all key UI elements are present and the credit display functions as intended.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize MV3 project using WXT and React",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add 'storage' and 'identity' permissions to manifest via wxt.config.ts",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create unified popup UI shell component (`SimplifiedPopup.tsx`) with placeholders",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement display logic for user's free trial credits in the popup",
            "description": "",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Extension: Implement Offline Mode Cleaning Engine",
        "description": "Implement the 'Offline Mode' functionality. This involves capturing selected text, processing it locally with a rules-based engine, structuring it as Markdown, and copying it to the clipboard.",
        "details": "The logic will reside primarily in the service worker or a script included by the popup. Use `chrome.scripting.executeScript` to get the selected text from the active tab. The rules-based cleaner should perform tasks like removing extra line breaks, fixing spacing, etc. The output should be formatted as clean Markdown. Use the `navigator.clipboard.writeText` API to copy the result automatically.",
        "testStrategy": "Unit test the cleaning and Markdown structuring functions with various input strings. Manually test the end-to-end flow in the browser: select different types of text on various websites, trigger the offline mode, and verify the clipboard content is correct.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "IHP: Implement Hybrid Pipeline Orchestrator",
            "description": "Implement the main orchestrator in `enhanced-processor.ts` to manage the two pipeline paths (Standard Readability vs. Intelligent Bypass) based on the bypass heuristic.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "IHP: Implement Bypass Heuristic",
            "description": "Implement the `shouldBypassReadability` decision heuristic to intelligently determine whether to use the standard Readability.js path or the advanced bypass pipeline for complex/technical content.",
            "details": "<info added on 2025-08-15T16:22:08.011Z>\nThe bypass heuristic is already implemented in `core/filters/boilerplate-filters.ts` within the `shouldBypassReadability` and `shouldPreserveElement` functions. The heuristic is robust, checking for whitelisted selectors, data attributes, and specific keywords in headings to identify technical content. The existing implementation fully meets the requirements of this subtask.\n</info added on 2025-08-15T16:22:08.011Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "IHP: Implement Two-Stage Cleaning (Safe & Aggressive Filters)",
            "description": "Implement the two-stage cleaning process: a 'safe' pass with UNWRAP rules for all content, and a conditional 'aggressive' pass with REMOVE rules for the bypass pipeline. This is located in `core/filters/boilerplate-filters.ts`.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "IHP: Implement Heuristic Scoring Engine",
            "description": "Build the `ScoringEngine` in `core/scoring/scoring-engine.ts` to analyze and score content 'islands' based on heuristics like link density, class names, and structure to find the main content block.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "IHP: Implement Content Pruning",
            "description": "Implement the `pruneNode` function within the ScoringEngine to recursively remove nested, low-scoring boilerplate from the winning content candidate.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 6,
            "title": "IHP: Implement Semantic Conversion for Tables",
            "description": "Enhance `core/turndown-config.ts` with a custom rule (`tableToGfmOrJson`) to intelligently convert HTML tables into GFM pipe tables or a structured JSON fallback to preserve their semantic meaning for LLMs.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Extension: AI Mode Trial Integration & Credit Display",
        "description": "Integrate the AI Mode into the UI. This includes handling the mode toggle, calling the backend AI proxy, and displaying the results. It also covers fetching and displaying the user's remaining credits.",
        "details": "First, use `chrome.identity.getProfileUserInfo()` to get an anonymous user identifier for backend calls. When the user toggles to 'AI Mode' and processes text, the extension will make a `fetch` request to the AI Proxy endpoint (Task 3). The UI should show a loading state while waiting for the response. The remaining credits should be fetched from the `/user/status` endpoint (Task 2) when the popup opens and displayed in the UI.",
        "testStrategy": "End-to-end test: Select text, switch to AI mode, process it, and verify the UI updates with the AI-cleaned text. Check that the credit counter updates correctly after each use. Test the loading and error states (e.g., when the backend returns an error).",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Extension: Handle Credit Exhaustion & 'Upgrade to BYOK' Flow",
        "description": "Implement the user flow for when free credits are exhausted. The AI mode should be disabled, and a clear call-to-action should be displayed, guiding the user to add their own API key.",
        "details": "The UI should conditionally render based on the credit count received from the backend. If `creditsRemaining` is 0, the 'AI Mode' processing button should be disabled. A non-intrusive message and a button/link labeled 'Unlock Unlimited Use' or 'Add Your API Key' should appear. Clicking this will reveal the inline settings view for BYOK.",
        "testStrategy": "Manually test by setting a user's credits to 0 in the backend database. Open the extension and verify that AI mode is disabled and the correct upgrade prompt is shown. Test that the UI reverts to normal if credits are added back.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Extension: Implement BYOK Settings and Processing Logic",
        "description": "Create the inline settings UI for users to input and save their API key. When a key is present, AI processing should use the user's key instead of the trial proxy.",
        "details": "Add an input field and a 'Save' button within the popup, revealed by the upgrade prompt. Use `chrome.storage.local.set` to save the API key securely. When making an AI call, the extension logic should first check if a user key exists in `chrome.storage.local`. If yes, it should make the API call directly to the AI provider (e.g., Groq), using the user's key. If no, it should use the trial proxy flow. Add a visual indicator to show that the user is in BYOK mode.",
        "testStrategy": "Test saving and retrieving the API key from `chrome.storage.local`. Use a valid test API key to perform an end-to-end test in BYOK mode, verifying that the network request goes directly to the AI provider. Test deleting the key and confirming the extension reverts to trial mode (if credits are available).",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Extension: Advanced Model Selection for BYOK Users",
        "description": "For BYOK users, add a UI element in the settings to select from a list of advanced AI models, such as 'Llama 3.1 8B Instant' and 'Gemini 2.0 Flash'.",
        "details": "In the inline settings area, add a `<select>` dropdown that is only visible and enabled when a user is in BYOK mode. Populate it with the predefined list of models. Save the user's selection in `chrome.storage.local`. When making a BYOK API call, retrieve the selected model and include it in the request payload to the AI provider.",
        "testStrategy": "In BYOK mode, select each model from the dropdown and perform a test processing task. Use browser developer tools to inspect the network request and verify that the correct model name is being sent in the API call payload. Confirm the setting persists between popup opens.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Feature: Implement Cite-First Capture and Footer",
        "description": "Implement the 'Cite-First Capture' feature. For all processed content (both Offline and AI modes), capture the source URL and timestamp, and append a formatted citation footer to the output.",
        "details": "In the service worker, when processing is initiated, use the `chrome.tabs` API to get the URL of the active tab. Create a timestamp with `new Date().toISOString()`. After the content is cleaned (by either engine), append a formatted string to the result. Example: `\n\n---\n*Cleaned from: [Page Title](source_url) on [Date]*`. The selection hash is a lower priority but can be implemented using a simple hashing function on the original selected text for preservation.",
        "testStrategy": "Test on various websites. Process content using both Offline and AI modes. Verify that the clipboard output for both modes contains a correctly formatted citation footer with the accurate URL and a recent timestamp.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-15T12:07:53.720Z",
      "updated": "2025-08-15T16:26:05.366Z",
      "description": "Tasks for master context"
    }
  }
}