{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Backend: Implement Global Budget Circuit Breaker",
        "description": "Set up the serverless backend environment and implement the non-negotiable Global Budget Circuit Breaker to cap weekly API spend. This is the highest priority task to mitigate financial risk.",
        "details": "Use a serverless framework (e.g., AWS Lambda with API Gateway, or Cloudflare Workers). Create a centralized configuration service to store the weekly budget (e.g., $100). Implement a durable counter (e.g., in DynamoDB, Redis, or KV store) to track cumulative spend for the current week. Create a middleware for the AI proxy that checks this counter before processing any request. If the budget is exceeded, the middleware should return a '429 Too Many Requests' or a custom 'service unavailable' error. \n\nPseudo-code:\n```javascript\n// Middleware for API Gateway/Proxy\nasync function circuitBreaker(request) {\n  const weeklySpend = await getWeeklySpend();\n  const weeklyBudget = await getWeeklyBudget();\n  if (weeklySpend >= weeklyBudget) {\n    return new Response('Free trial temporarily unavailable', { status: 429 });\n  }\n  // Proceed to next handler\n}\n```",
        "testStrategy": "Unit test the budget checking logic. Create integration tests that simulate hitting the budget limit and verify that the API correctly returns a 429 error. Manually test by setting a low budget, making API calls to exceed it, and confirming the service is disabled.",
        "priority": "high",
        "dependencies": [],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Backend: User Identity and Credit Tracking Service",
        "description": "Create a backend service to manage user credits. This service will use `chrome.identity` to generate a stable, anonymous user ID, provision initial credits, and decrement them upon use.",
        "details": "Create a serverless function endpoint `/user/status`. On first call with a new `chrome.identity` token, create a user record in a database (e.g., DynamoDB) with `userId`, `credits: 150`, and `monthlyResetDate`. Subsequent calls return the current credit count. Create another internal endpoint `/credits/decrement` for the AI proxy to call. This endpoint should be secured and only callable by other backend services. \n\nSchema for User Table:\n- `userId` (Partition Key, String from `chrome.identity` hash)\n- `creditsRemaining` (Number)\n- `lastResetTimestamp` (Number)",
        "testStrategy": "Unit test the credit provisioning and decrementing logic. Integration test the API endpoints: verify a new user gets 150 credits, and that calling the decrement endpoint correctly reduces the count. Test the edge case where credits are zero.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Backend: AI Proxy Service for Trial Mode",
        "description": "Develop a serverless function that acts as a secure proxy for the free trial AI mode. It will handle requests from the extension, validate credits, and call the designated AI model API.",
        "details": "Create a serverless function endpoint `/proxy/ai-process`. This function will: \n1. Receive the user's anonymous token and the text to process.\n2. Call the Credit Tracking Service (Task 2) to verify the user has > 0 credits. If not, return an error.\n3. Call the `GPT OSS 20B` model API (hosted via Groq, as specified) using the company's secret API key.\n4. On successful response, call the Credit Tracking Service to decrement the user's credit count.\n5. Track the cost of the API call and update the Global Budget counter (Task 1).\n6. Return the processed text to the extension.",
        "testStrategy": "Integration test the entire flow: send a request, verify credit check, mock the external AI API call, verify credit decrement, and check the response format. Test failure modes: no credits, upstream API failure, etc. Use a test API key and a separate budget for testing.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Extension: MV3 Scaffold and Unified Popup UI Shell",
        "description": "Set up the basic Chrome Extension using the Manifest V3 standard. Create the main popup UI with a unified interface for mode selection, credit display, and inline settings.",
        "details": "Use a modern framework like React or Vue, or plain HTML/CSS/JS. The `manifest.json` should declare `service_worker`, `action` (for the popup), `storage`, and `identity` permissions. The popup UI should be a single view with progressively disclosed elements. Initially, it will show the 'Offline'/'AI' mode toggle. Placeholders for the credit counter and settings area should be included.",
        "testStrategy": "Load the extension in Chrome. Verify the popup opens correctly. Check the browser's developer console for any manifest errors. Ensure the basic UI elements are rendered as expected.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Extension: Implement Offline Mode Cleaning Engine",
        "description": "Implement the 'Offline Mode' functionality. This involves capturing selected text, processing it locally with a rules-based engine, structuring it as Markdown, and copying it to the clipboard.",
        "details": "The logic will reside primarily in the service worker or a script included by the popup. Use `chrome.scripting.executeScript` to get the selected text from the active tab. The rules-based cleaner should perform tasks like removing extra line breaks, fixing spacing, etc. The output should be formatted as clean Markdown. Use the `navigator.clipboard.writeText` API to copy the result automatically.",
        "testStrategy": "Unit test the cleaning and Markdown structuring functions with various input strings. Manually test the end-to-end flow in the browser: select different types of text on various websites, trigger the offline mode, and verify the clipboard content is correct.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "IHP: Implement Hybrid Pipeline Orchestrator",
            "description": "Implement the main orchestrator in `enhanced-processor.ts` to manage the two pipeline paths (Standard Readability vs. Intelligent Bypass) based on the bypass heuristic.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 2,
            "title": "IHP: Implement Bypass Heuristic",
            "description": "Implement the `shouldBypassReadability` decision heuristic to intelligently determine whether to use the standard Readability.js path or the advanced bypass pipeline for complex/technical content.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 3,
            "title": "IHP: Implement Two-Stage Cleaning (Safe & Aggressive Filters)",
            "description": "Implement the two-stage cleaning process: a 'safe' pass with UNWRAP rules for all content, and a conditional 'aggressive' pass with REMOVE rules for the bypass pipeline. This is located in `core/filters/boilerplate-filters.ts`.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 4,
            "title": "IHP: Implement Heuristic Scoring Engine",
            "description": "Build the `ScoringEngine` in `core/scoring/scoring-engine.ts` to analyze and score content 'islands' based on heuristics like link density, class names, and structure to find the main content block.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 5,
            "title": "IHP: Implement Content Pruning",
            "description": "Implement the `pruneNode` function within the ScoringEngine to recursively remove nested, low-scoring boilerplate from the winning content candidate.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          },
          {
            "id": 6,
            "title": "IHP: Implement Semantic Conversion for Tables",
            "description": "Enhance `core/turndown-config.ts` with a custom rule (`tableToGfmOrJson`) to intelligently convert HTML tables into GFM pipe tables or a structured JSON fallback to preserve their semantic meaning for LLMs.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 5
          }
        ]
      },
      {
        "id": 6,
        "title": "Extension: AI Mode Trial Integration & Credit Display",
        "description": "Integrate the AI Mode into the UI. This includes handling the mode toggle, calling the backend AI proxy, and displaying the results. It also covers fetching and displaying the user's remaining credits.",
        "details": "First, use `chrome.identity.getProfileUserInfo()` to get an anonymous user identifier for backend calls. When the user toggles to 'AI Mode' and processes text, the extension will make a `fetch` request to the AI Proxy endpoint (Task 3). The UI should show a loading state while waiting for the response. The remaining credits should be fetched from the `/user/status` endpoint (Task 2) when the popup opens and displayed in the UI.",
        "testStrategy": "End-to-end test: Select text, switch to AI mode, process it, and verify the UI updates with the AI-cleaned text. Check that the credit counter updates correctly after each use. Test the loading and error states (e.g., when the backend returns an error).",
        "priority": "high",
        "dependencies": [
          3,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Extension: Handle Credit Exhaustion & 'Upgrade to BYOK' Flow",
        "description": "Implement the user flow for when free credits are exhausted. The AI mode should be disabled, and a clear call-to-action should be displayed, guiding the user to add their own API key.",
        "details": "The UI should conditionally render based on the credit count received from the backend. If `creditsRemaining` is 0, the 'AI Mode' processing button should be disabled. A non-intrusive message and a button/link labeled 'Unlock Unlimited Use' or 'Add Your API Key' should appear. Clicking this will reveal the inline settings view for BYOK.",
        "testStrategy": "Manually test by setting a user's credits to 0 in the backend database. Open the extension and verify that AI mode is disabled and the correct upgrade prompt is shown. Test that the UI reverts to normal if credits are added back.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Extension: Implement BYOK Settings and Processing Logic",
        "description": "Create the inline settings UI for users to input and save their API key. When a key is present, AI processing should use the user's key instead of the trial proxy.",
        "details": "Add an input field and a 'Save' button within the popup, revealed by the upgrade prompt. Use `chrome.storage.local.set` to save the API key securely. When making an AI call, the extension logic should first check if a user key exists in `chrome.storage.local`. If yes, it should make the API call directly to the AI provider (e.g., Groq), using the user's key. If no, it should use the trial proxy flow. Add a visual indicator to show that the user is in BYOK mode.",
        "testStrategy": "Test saving and retrieving the API key from `chrome.storage.local`. Use a valid test API key to perform an end-to-end test in BYOK mode, verifying that the network request goes directly to the AI provider. Test deleting the key and confirming the extension reverts to trial mode (if credits are available).",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Extension: Advanced Model Selection for BYOK Users",
        "description": "For BYOK users, add a UI element in the settings to select from a list of advanced AI models, such as 'Llama 3.1 8B Instant' and 'Gemini 2.0 Flash'.",
        "details": "In the inline settings area, add a `<select>` dropdown that is only visible and enabled when a user is in BYOK mode. Populate it with the predefined list of models. Save the user's selection in `chrome.storage.local`. When making a BYOK API call, retrieve the selected model and include it in the request payload to the AI provider.",
        "testStrategy": "In BYOK mode, select each model from the dropdown and perform a test processing task. Use browser developer tools to inspect the network request and verify that the correct model name is being sent in the API call payload. Confirm the setting persists between popup opens.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Feature: Implement Cite-First Capture and Footer",
        "description": "Implement the 'Cite-First Capture' feature. For all processed content (both Offline and AI modes), capture the source URL and timestamp, and append a formatted citation footer to the output.",
        "details": "In the service worker, when processing is initiated, use the `chrome.tabs` API to get the URL of the active tab. Create a timestamp with `new Date().toISOString()`. After the content is cleaned (by either engine), append a formatted string to the result. Example: `\n\n---\n*Cleaned from: [Page Title](source_url) on [Date]*`. The selection hash is a lower priority but can be implemented using a simple hashing function on the original selected text for preservation.",
        "testStrategy": "Test on various websites. Process content using both Offline and AI modes. Verify that the clipboard output for both modes contains a correctly formatted citation footer with the accurate URL and a recent timestamp.",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-15T12:07:53.720Z",
      "updated": "2025-08-15T16:04:53.892Z",
      "description": "Tasks for master context"
    }
  }
}